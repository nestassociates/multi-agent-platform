# Research & Technology Decisions

**Feature**: Multi-Agent Real Estate Platform
**Date**: 2025-10-29
**Status**: Phase 0 Complete

## Overview

This document captures research findings, technology decisions, and architectural patterns for the Multi-Agent Real Estate Platform. All decisions are based on the requirements in [spec.md](spec.md) and technical context in [plan.md](plan.md).

---

## 1. Monorepo Strategy

### Decision: Turborepo

**Rationale**:
- **Performance**: Incremental builds with intelligent caching - only rebuilds changed packages
- **Developer Experience**: Single `npm install` at root, shared tooling configuration
- **Scalability**: Proven at scale (Vercel, Netflix, Twitch use Turborepo in production)
- **Pipeline Orchestration**: Parallel task execution with dependency awareness
- **Type Safety**: Seamless TypeScript project references across packages

**Alternatives Considered**:
- **Nx**: More feature-rich but heavier, includes code generation we don't need
- **Lerna**: Legacy tool, less active development, no built-in caching
- **pnpm workspaces only**: No task orchestration or caching layer

**Implementation Notes**:
- `turbo.json` defines build pipeline: `build`, `test`, `lint`, `deploy`
- Packages declare dependencies via `package.json` `dependencies` field
- Turborepo automatically determines build order based on package graph

**Resources**:
- [Turborepo Handbook](https://turbo.build/repo/docs/handbook)
- [Monorepo Best Practices](https://turbo.build/repo/docs/core-concepts/monorepos)

---

## 2. Dashboard Framework

### Decision: Next.js 14 App Router

**Rationale**:
- **Server Components**: Reduced JavaScript bundle, faster initial page loads
- **API Routes**: Co-locate backend endpoints with frontend (single deployment)
- **Route Groups**: `(admin)` and `(agent)` routes share infrastructure but enforce separation
- **Middleware**: Built-in support for auth checks, role-based redirects
- **Streaming**: RSC streaming for fast Time to First Byte (TTFB)
- **Vercel Integration**: First-class deployment support, automatic edge optimization

**Why App Router over Pages Router**:
- Server Components reduce client-side JS by 40-60% (better performance)
- Simplified data fetching (no getServerSideProps/getStaticProps confusion)
- Built-in layouts and loading states
- Future-proof: App Router is the recommended approach for new Next.js projects

**Alternatives Considered**:
- **Remix**: Great DX but smaller ecosystem, less Vercel integration
- **SvelteKit**: Excellent performance but team may have less TypeScript/React experience
- **Nuxt.js**: Vue-based, team familiar with React makes Next.js better fit

**Implementation Notes**:
- Route groups `(admin)` and `(agent)` ensure URL structure: `/agents/*`, `/dashboard/*`
- Middleware checks user role from Supabase session, redirects unauthorized users
- Server Actions for mutations (form submissions) instead of API routes where possible

**Resources**:
- [Next.js App Router Documentation](https://nextjs.org/docs/app)
- [Server Components Explained](https://nextjs.org/docs/app/building-your-application/rendering/server-components)

---

## 3. Static Site Generator for Agent Microsites

### Decision: Astro 4.x

**Rationale**:
- **Zero JavaScript by Default**: Astro ships no JS unless explicitly needed (Lighthouse 100 scores)
- **Build Speed**: Faster than Next.js SSG for static-only sites (benchmarks show 2-3x faster)
- **Content Collections**: Type-safe content with Zod validation (perfect for our JSON data injection)
- **Partial Hydration**: "Islands" architecture - only hydrate interactive components (e.g., property filters)
- **Framework Agnostic**: Can use React components where needed (e.g., contact forms) but renders to static HTML

**Why Astro over Next.js SSG**:
- Next.js SSG still includes React runtime (adds ~40KB gzipped baseline)
- Astro's zero-JS default aligns with static content sites (blogs, property listings)
- Build times: Astro can generate 1,000 sites faster than Next.js SSG

**Alternatives Considered**:
- **Next.js Static Export**: Requires React runtime, slower builds at scale
- **Gatsby**: Heavy, slow builds, declining community support
- **11ty (Eleventy)**: Excellent but template syntax less familiar than JSX/Astro

**Implementation Notes**:
- Agent data injected via `src/data/agent.json` (generated by build system)
- Content (blog posts, areas) loaded from JSON at build time
- Properties fetched client-side via API for real-time updates (optional: pre-render at build time)
- Tailwind CSS for styling (matches dashboard for consistency)

**Resources**:
- [Astro Documentation](https://docs.astro.build/)
- [Astro Islands Architecture](https://docs.astro.build/en/concepts/islands/)
- [Astro Content Collections](https://docs.astro.build/en/guides/content-collections/)

---

## 4. Database & Backend

### Decision: Supabase (PostgreSQL + PostGIS + Auth + Storage)

**Rationale**:
- **All-in-One**: Database, authentication, storage, real-time subscriptions in single platform
- **PostgreSQL**: Industry-standard, excellent for relational data with complex queries
- **PostGIS Extension**: Required for geospatial queries (territories, property locations)
- **Row Level Security (RLS)**: Database-enforced data isolation (agents can't access other agents' data)
- **Supabase Auth**: JWT-based, supports 2FA, integrates with Next.js middleware
- **Supabase Storage**: S3-compatible object storage for images, PDFs, etc.
- **UK Region**: Data residency compliance for UK-focused platform

**Why Supabase over Alternatives**:
- **vs. Firebase**: PostgreSQL (relational) better than NoSQL for structured real estate data
- **vs. PlanetScale**: Supabase includes auth + storage, PlanetScale is DB only
- **vs. Neon**: Supabase has auth/storage built-in, better DX for full-stack apps

**Alternatives Considered**:
- **Firebase**: NoSQL not ideal for complex relationships (agents → properties → territories)
- **PlanetScale + Clerk**: Requires integrating 3+ services (DB, auth, storage)
- **Self-hosted PostgreSQL**: Higher operational overhead, need to manage backups/scaling

**Implementation Notes**:
- RLS policies created per table (admin, agent, public access levels)
- PostGIS geography type for territories (polygon boundaries)
- PostGIS point type for property locations (enables radius searches)
- Supabase Storage buckets: `avatars`, `content-images`, `property-images`, `documents`
- Database migrations via Supabase CLI (stored in `supabase/migrations/`)

**Resources**:
- [Supabase Documentation](https://supabase.com/docs)
- [PostGIS Documentation](https://postgis.net/documentation/)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)

---

## 5. Authentication & Authorization

### Decision: Supabase Auth + Next.js Middleware

**Rationale**:
- **JWT-Based**: Stateless, scales horizontally, works with Vercel serverless
- **2FA Support**: TOTP (Time-based One-Time Password) via QR codes
- **Password Policies**: Configurable minimum length, complexity requirements
- **Session Management**: Automatic refresh token rotation, secure cookie storage
- **Social Logins**: Optional future addition (Google, Microsoft) without code changes

**Authorization Strategy**:
- **Role-Based Access Control (RBAC)**: Three roles stored in `profiles.role` (super_admin, admin, agent)
- **Middleware Enforcement**: Next.js middleware checks role before rendering protected routes
- **RLS Policies**: Database-level enforcement (defense in depth)
- **API Route Guards**: Every API route validates user role from JWT claims

**Alternatives Considered**:
- **Clerk**: Excellent UX but additional cost, Supabase Auth meets requirements
- **Auth0**: Overkill for needs, higher complexity and cost
- **NextAuth.js**: Requires more manual setup, Supabase Auth is integrated

**Implementation Notes**:
- Store role in `profiles` table with foreign key to `auth.users`
- Middleware checks `request.cookies` for Supabase session token
- Decode JWT to get `user_id`, query `profiles` table for role
- Redirect based on role: admin → `/agents`, agent → `/dashboard`

**Security Considerations**:
- Never expose service role key client-side (only in API routes)
- Use anonymous key for public endpoints
- Rate limit authentication endpoints (5 attempts per 15 minutes)
- Account lockout after 10 failed login attempts

**Resources**:
- [Supabase Auth Documentation](https://supabase.com/docs/guides/auth)
- [Next.js Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)

---

## 6. UI Component Library

### Decision: shadcn/ui (Radix UI + Tailwind CSS)

**Rationale**:
- **Copy-Paste Components**: No npm package, full control over component code
- **Accessibility Built-In**: Based on Radix UI primitives (WAI-ARIA compliant)
- **Customizable**: Tailwind-based, easy to match brand colors/typography
- **TypeScript Native**: Full type safety out of the box
- **No Runtime Overhead**: Components are code you own, no library bundle

**Why shadcn/ui over Alternatives**:
- **vs. Material-UI (MUI)**: Lighter weight, better Tailwind integration, easier customization
- **vs. Ant Design**: Less opinionated design, more modern aesthetic
- **vs. Chakra UI**: shadcn/ui is copy-paste (no version lock-in), Chakra has runtime

**Alternatives Considered**:
- **Headless UI**: Similar to Radix but shadcn/ui provides pre-styled components
- **DaisyUI**: Tailwind plugin, less customizable than component-based approach
- **Park UI**: Newer, smaller community than shadcn/ui

**Implementation Notes**:
- Install components as needed: `npx shadcn-ui@latest add button dialog table`
- Components live in `packages/ui/components/` (shared across dashboard and future apps)
- Customize via `tailwind.config.js` theme variables
- Use compound components pattern for complex UI (e.g., Dialog, Dropdown)

**Resources**:
- [shadcn/ui Documentation](https://ui.shadcn.com/)
- [Radix UI Primitives](https://www.radix-ui.com/primitives)

---

## 7. Form Handling & Validation

### Decision: React Hook Form + Zod

**Rationale**:
- **Performance**: Uncontrolled components minimize re-renders (faster than Formik)
- **TypeScript Integration**: Type-safe forms with Zod schema inference
- **Bundle Size**: 9KB gzipped (Formik is 15KB)
- **Validation**: Zod provides both runtime validation and TypeScript types
- **Server-Side Validation**: Same Zod schemas used in API routes (DRY principle)

**Why Zod over Alternatives**:
- **vs. Yup**: Zod is TypeScript-first, better type inference
- **vs. Joi**: Server-only, can't use client-side (Zod works everywhere)
- **vs. Valibot**: Newer, smaller community, Zod more battle-tested

**Alternatives Considered**:
- **Formik**: More mature but heavier and slower
- **TanStack Form**: Good but newer, less ecosystem support
- **Plain HTML Forms**: No validation, poor UX for complex forms

**Implementation Notes**:
- Create Zod schemas in `packages/validation/` (e.g., `agent.ts`, `content.ts`)
- Use `zodResolver` from `@hookform/resolvers/zod` to integrate with React Hook Form
- Forms in Next.js can use Server Actions for submission (progressive enhancement)
- Error messages from Zod automatically shown via React Hook Form

**Example Zod Schema**:
```typescript
// packages/validation/agent.ts
import { z } from 'zod';

export const createAgentSchema = z.object({
  email: z.string().email('Invalid email address'),
  first_name: z.string().min(1, 'First name required'),
  last_name: z.string().min(1, 'Last name required'),
  subdomain: z.string()
    .regex(/^[a-z0-9-]+$/, 'Only lowercase letters, numbers, and hyphens')
    .min(3, 'At least 3 characters'),
  apex27_branch_id: z.string().optional(),
  bio: z.string().optional(),
});

export type CreateAgentInput = z.infer<typeof createAgentSchema>;
```

**Resources**:
- [React Hook Form Documentation](https://react-hook-form.com/)
- [Zod Documentation](https://zod.dev/)

---

## 8. Rich Text Editor

### Decision: Tiptap (ProseMirror-based)

**Rationale**:
- **Headless**: Full control over UI (matches shadcn/ui design)
- **Extensible**: Plugin architecture for custom functionality
- **Accessibility**: Keyboard shortcuts, screen reader support
- **Markdown Support**: Can import/export Markdown
- **Real-Time Collaboration**: Optional Yjs integration for future
- **TypeScript**: First-class TypeScript support

**Why Tiptap over Alternatives**:
- **vs. Slate**: Tiptap has better documentation, more extensions
- **vs. Quill**: Tiptap more modern, better React integration
- **vs. Draft.js**: Deprecated by Meta, Tiptap actively maintained

**Alternatives Considered**:
- **Lexical (Meta)**: Very new, less community support than Tiptap
- **CKEditor**: Heavy, enterprise-focused, overkill for needs
- **TinyMCE**: jQuery-based, not modern React

**Implementation Notes**:
- Install extensions: `@tiptap/starter-kit`, `@tiptap/extension-image`, `@tiptap/extension-link`
- Create reusable `RichTextEditor` component in `packages/ui/components/`
- Store content as HTML in database (easier to render on agent sites)
- Sanitize HTML on render using `DOMPurify` (XSS prevention)
- Image uploads handled by custom extension (uploads to Supabase Storage, inserts URL)

**Extensions Used**:
- Bold, Italic, Underline, Strike
- Headings (H1-H6)
- Bullet List, Ordered List
- Link (with validation)
- Image (with Supabase Storage upload)
- Blockquote
- Code Block (optional)

**Resources**:
- [Tiptap Documentation](https://tiptap.dev/)
- [Tiptap React Guide](https://tiptap.dev/guide/react)

---

## 9. Maps & Geospatial

### Decision: Mapbox GL JS + PostGIS

**Rationale**:
- **Vector Maps**: Smooth zooming, fast rendering, 60fps performance
- **Drawing Tools**: `@mapbox/mapbox-gl-draw` for polygon creation
- **Customizable**: Full control over map style (can match brand colors)
- **Geospatial Queries**: PostGIS provides efficient polygon overlap checks, point-in-polygon queries
- **Pricing**: Free tier includes 50,000 loads/month (sufficient for admin-only feature)

**Why Mapbox over Alternatives**:
- **vs. Google Maps**: Mapbox cheaper, more customizable, better for custom styling
- **vs. Leaflet**: Mapbox GL JS more performant (GPU-accelerated), native vector support
- **vs. MapLibre GL**: Mapbox has better documentation and ecosystem

**Alternatives Considered**:
- **Google Maps Platform**: More expensive, less customizable
- **OpenLayers**: More complex API, steeper learning curve
- **Leaflet**: Raster-based (slower), no native vector tiles

**Implementation Notes**:
- Install: `mapbox-gl`, `@mapbox/mapbox-gl-draw`
- Store Mapbox access token in environment variables (public token for map display)
- Territory polygons stored as PostGIS geography type (SRID 4326 - WGS84)
- Use PostGIS `ST_Intersects` for overlap detection
- Use PostGIS `ST_Area` for property count estimation (combined with OS Data Hub API)

**PostGIS Queries**:
```sql
-- Check if new territory overlaps existing territories
SELECT id, agent_id, name
FROM territories
WHERE ST_Intersects(boundary, ST_GeogFromGeoJSON($1));

-- Find properties within territory
SELECT id, title, postcode
FROM properties
WHERE ST_Within(location, (SELECT boundary FROM territories WHERE id = $1));
```

**Resources**:
- [Mapbox GL JS Documentation](https://docs.mapbox.com/mapbox-gl-js/guides/)
- [Mapbox Draw Plugin](https://github.com/mapbox/mapbox-gl-draw)
- [PostGIS Documentation](https://postgis.net/docs/)

---

## 10. External API Integration

### Decision: Native fetch + Zod Validation

**Rationale**:
- **No Dependencies**: `fetch` is native in Node.js 18+, no axios needed
- **Type Safety**: Validate API responses with Zod schemas (catch breaking changes early)
- **Error Handling**: Consistent error types across all API integrations
- **Retry Logic**: Implement exponential backoff for transient failures
- **Logging**: Structured logs for all external API calls (debugging, monitoring)

**APIs to Integrate**:

1. **Apex27 CRM Webhook** (Inbound)
   - Receive property create/update/delete events
   - Validate HMAC-SHA256 signature
   - Schema: `packages/validation/webhooks.ts`

2. **OS Data Hub Features API** (Outbound)
   - Query residential property count within polygon
   - API Key authentication
   - Rate limit: 600 requests/minute (sufficient)

3. **Vercel Deployment API** (Outbound)
   - Trigger Astro site builds
   - Monitor build status
   - Bearer token authentication

**Implementation Pattern**:
```typescript
// packages/shared-types/external-apis.ts
import { z } from 'zod';

export const apex27PropertySchema = z.object({
  id: z.string(),
  branch_id: z.string(),
  type: z.enum(['sale', 'let', 'commercial']),
  title: z.string(),
  price: z.number(),
  // ... full schema
});

// apps/dashboard/lib/apex27-client.ts
export async function validateApex27Webhook(
  payload: unknown,
  signature: string
): Promise<Apex27Property> {
  // 1. Verify HMAC-SHA256 signature
  const expectedSignature = crypto
    .createHmac('sha256', process.env.APEX27_WEBHOOK_SECRET!)
    .update(JSON.stringify(payload))
    .digest('hex');

  if (signature !== expectedSignature) {
    throw new Error('Invalid webhook signature');
  }

  // 2. Validate payload structure
  return apex27PropertySchema.parse(payload);
}
```

**Alternatives Considered**:
- **axios**: Adds dependency, fetch is sufficient
- **ky**: Good but fetch is built-in
- **GraphQL Client**: Apex27 and OS Data Hub are REST APIs

**Resources**:
- [Fetch API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
- [Zod Parse vs SafeParse](https://zod.dev/?id=safeparse)

---

## 11. Build System Architecture

### Decision: Vercel Cron + Queue Pattern + Parallel Processing

**Rationale**:
- **Vercel Cron**: Serverless cron jobs (no separate cron service needed)
- **Queue Table**: PostgreSQL table tracks pending builds (simple, no Redis needed)
- **Priority System**: P1-P4 priorities ensure urgent builds process first
- **Parallel Processing**: Process up to 20 builds concurrently (Vercel concurrency limits)
- **Duplicate Detection**: Prevents queue flooding (only one pending build per agent)
- **Retry Logic**: Exponential backoff for transient failures (network issues, API limits)

**Why Queue Table over Message Queue**:
- **Simplicity**: No additional infrastructure (Redis, RabbitMQ, AWS SQS)
- **Atomicity**: PostgreSQL transactions ensure exactly-once processing
- **Queryability**: Easy to debug (view queue contents in SQL query)
- **Cost**: No additional service costs

**Alternatives Considered**:
- **Vercel Background Functions**: In beta, not production-ready
- **AWS SQS**: Overkill, adds complexity and cost
- **Bull (Redis Queue)**: Requires Redis instance, more moving parts

**Implementation Notes**:
```sql
-- Build queue table schema
CREATE TABLE build_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  priority INTEGER NOT NULL CHECK (priority BETWEEN 1 AND 4),
  status TEXT NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  trigger_reason TEXT NOT NULL,
  build_logs TEXT,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Prevent duplicate pending builds for same agent
CREATE UNIQUE INDEX idx_build_queue_pending_agent
ON build_queue (agent_id)
WHERE status = 'pending';
```

**Cron Job Flow** (runs every 2 minutes):
1. Query up to 20 pending builds ordered by priority, created_at
2. Mark selected builds as 'processing' in single transaction
3. Process builds in parallel (Promise.allSettled)
4. For each build:
   - Fetch agent data, content, properties, global templates
   - Generate JSON data file
   - Call Vercel API to trigger Astro build
   - Poll for completion or timeout after 5 minutes
5. Update build status to 'completed' or 'failed'
6. If failed and retry_count < 3, create new pending build with exponential backoff

**Resources**:
- [Vercel Cron Jobs](https://vercel.com/docs/cron-jobs)
- [PostgreSQL Advisory Locks](https://www.postgresql.org/docs/current/explicit-locking.html)

---

## 12. Email Service

### Decision: Resend (SendGrid Alternative)

**Rationale**:
- **Developer Experience**: Best-in-class DX (simple API, great docs)
- **React Email Templates**: Use React components for emails (reuse shadcn/ui styles)
- **Deliverability**: High inbox rates, good reputation
- **Pricing**: Free tier: 3,000 emails/month, then $20/month for 50,000 emails
- **Analytics**: Open rates, click rates, bounce tracking

**Why Resend over Alternatives**:
- **vs. SendGrid**: Resend has better DX, cleaner API, React email support
- **vs. Postmark**: Resend cheaper, React email templates
- **vs. AWS SES**: Resend easier to set up, better deliverability out of the box

**Alternatives Considered**:
- **SendGrid**: Good but complex API, no React email support
- **Postmark**: Excellent deliverability but more expensive
- **AWS SES**: Cheapest but complex setup, manual bounce handling

**Implementation Notes**:
- Install: `resend`, `@react-email/components`
- Store API key in environment variables
- Create email templates in `packages/email/templates/` using React Email
- Use `@react-email/render` to convert React components to HTML
- Send emails from API routes or Server Actions

**Email Template Example**:
```tsx
// packages/email/templates/content-approved.tsx
import { Html, Button, Text } from '@react-email/components';

export default function ContentApprovedEmail({
  agentName,
  contentTitle,
  viewUrl,
}: {
  agentName: string;
  contentTitle: string;
  viewUrl: string;
}) {
  return (
    <Html>
      <Text>Hi {agentName},</Text>
      <Text>
        Your content "{contentTitle}" has been approved and will be published
        on your site shortly.
      </Text>
      <Button href={viewUrl}>View Live Content</Button>
    </Html>
  );
}
```

**Resources**:
- [Resend Documentation](https://resend.com/docs)
- [React Email Documentation](https://react.email/)

---

## 13. Testing Strategy

### Decision: Multi-Layer Testing with Playwright + Jest

**Rationale**:
- **Unit Tests**: Jest for pure functions, utilities, validation schemas
- **Component Tests**: React Testing Library for UI components
- **Integration Tests**: Playwright for API endpoint testing (faster than E2E)
- **E2E Tests**: Playwright for critical user journeys (full browser automation)
- **Contract Tests**: Validate API request/response against OpenAPI schema

**Why Playwright over Alternatives**:
- **Cross-Browser**: Chromium, Firefox, WebKit (Safari) support out of the box
- **Speed**: Parallel test execution, faster than Cypress
- **API Testing**: Built-in support for API testing (no browser needed)
- **Trace Viewer**: Visual debugging of test failures
- **Auto-Wait**: Automatically waits for elements (fewer flaky tests)

**Alternatives Considered**:
- **Cypress**: Good but slower, less cross-browser support
- **Puppeteer**: Lower-level API, more manual setup
- **Selenium**: Outdated, slower, more flaky tests

**Testing Pyramid**:
- **70% Unit Tests**: Fast, isolated, test pure logic
- **20% Integration Tests**: Test API endpoints, database queries, RLS policies
- **10% E2E Tests**: Test critical user flows end-to-end

**Critical E2E Test Scenarios**:
1. Admin creates agent → Agent logs in → Updates profile → Site builds
2. Agent creates blog post → Submits for review → Admin approves → Content appears on site
3. Apex27 webhook → Property stored → Property appears on agent site
4. Admin draws territory → System calculates property count → Territory saved

**Implementation Notes**:
```typescript
// tests/e2e/agent-onboarding.spec.ts
import { test, expect } from '@playwright/test';

test('Agent onboarding flow', async ({ page }) => {
  // Admin creates agent
  await page.goto('/agents/new');
  await page.fill('[name="email"]', 'john@example.com');
  await page.fill('[name="first_name"]', 'John');
  await page.fill('[name="subdomain"]', 'john-smith');
  await page.click('button[type="submit"]');

  // Check welcome email sent (mock email service in test env)
  // ... assertions

  // Agent logs in
  await page.goto('/login');
  await page.fill('[name="email"]', 'john@example.com');
  await page.fill('[name="password"]', 'temporary-password');
  await page.click('button[type="submit"]');

  // Agent changes password
  await expect(page).toHaveURL('/reset-password');
  // ... password change flow

  // Agent updates profile
  await page.goto('/profile');
  await page.fill('[name="phone"]', '07700 900000');
  await page.click('button[type="submit"]');

  // Verify site rebuild triggered
  // ... check build queue
});
```

**Resources**:
- [Playwright Documentation](https://playwright.dev/)
- [Jest Documentation](https://jestjs.io/)
- [React Testing Library](https://testing-library.com/react)

---

## 14. Accessibility Implementation

### Decision: Automated Testing + Manual Verification

**Rationale**:
- **Automated**: Catch 40-60% of issues automatically (axe-core integration)
- **Manual**: Required for context-dependent issues (keyboard navigation, screen reader)
- **WCAG 2.1 AA**: Legal requirement, improves usability for all users
- **Continuous Testing**: Run axe-core in CI pipeline, fail build on violations

**Tools**:
- **axe-core**: Industry-standard accessibility testing engine
- **@axe-core/playwright**: Playwright integration for E2E tests
- **eslint-plugin-jsx-a11y**: Catch issues during development
- **NVDA/JAWS/VoiceOver**: Manual screen reader testing

**Implementation Notes**:
```typescript
// tests/e2e/accessibility.spec.ts
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test('Agent dashboard accessibility', async ({ page }) => {
  await page.goto('/dashboard');

  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])
    .analyze();

  expect(accessibilityScanResults.violations).toEqual([]);
});
```

**WCAG 2.1 AA Requirements**:
- **Perceivable**: Alt text for images, captions for videos, color contrast 4.5:1
- **Operable**: Keyboard navigation, focus indicators, skip links
- **Understandable**: Clear labels, error messages, consistent navigation
- **Robust**: Semantic HTML, ARIA labels where needed, valid HTML

**Manual Testing Checklist**:
- [ ] All interactive elements keyboard accessible (Tab, Enter, Space)
- [ ] Focus indicators visible and clear
- [ ] Screen reader announces content correctly
- [ ] Form errors announced to screen readers
- [ ] Modal dialogs trap focus appropriately
- [ ] Skip links allow bypassing navigation

**Resources**:
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [axe-core Documentation](https://github.com/dequelabs/axe-core)
- [WebAIM Color Contrast Checker](https://webaim.org/resources/contrastchecker/)

---

## 15. Monitoring & Observability

### Decision: Vercel Analytics + Sentry + Custom Metrics

**Rationale**:
- **Vercel Analytics**: Real-time performance metrics (Web Vitals, bandwidth, errors)
- **Sentry**: Error tracking with stack traces, breadcrumbs, user context
- **Custom Metrics**: Admin dashboard widgets for build queue, webhook success rate
- **Logging**: Structured JSON logs (timestamp, level, context, message)

**Why This Stack**:
- **Vercel Analytics**: Free with Vercel hosting, no integration needed
- **Sentry**: Best-in-class error tracking, free tier covers initial launch
- **Custom Metrics**: Business-specific metrics not covered by general tools

**Alternatives Considered**:
- **New Relic**: Expensive, overkill for needs
- **Datadog**: Great but costly, Sentry + Vercel Analytics sufficient
- **LogRocket**: Session replay useful but expensive

**Implementation Notes**:
```typescript
// lib/monitoring.ts
import * as Sentry from '@sentry/nextjs';

export function initMonitoring() {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    tracesSampleRate: 0.1, // 10% of transactions
    environment: process.env.NODE_ENV,
    beforeSend(event) {
      // Don't send PII (personally identifiable information)
      if (event.user) {
        delete event.user.email;
        delete event.user.ip_address;
      }
      return event;
    },
  });
}

export function logError(error: Error, context?: Record<string, any>) {
  Sentry.captureException(error, {
    extra: context,
  });
  console.error('[ERROR]', error.message, context);
}
```

**Custom Metrics Dashboard**:
- Build queue depth (real-time)
- Average build time (last 24 hours)
- Webhook success rate (last 24 hours)
- API response times (p50, p95, p99)
- Database query times (slow query log)

**Alert Configuration**:
- **Critical** (SMS/phone): Site down >5 min, DB connection lost, API errors >10% for 5 min
- **Warning** (email within 1 hour): API p95 >500ms, build queue depth >50, webhook errors 3+ in 1 hour
- **Info** (daily digest): Daily metrics summary, content pending approval count

**Resources**:
- [Vercel Analytics Documentation](https://vercel.com/docs/analytics)
- [Sentry Next.js Setup](https://docs.sentry.io/platforms/javascript/guides/nextjs/)

---

## 16. Deployment Strategy

### Decision: Vercel Platform (All Applications)

**Rationale**:
- **Unified Platform**: Both Next.js dashboard and Astro sites deploy to Vercel
- **Zero Configuration**: Vercel auto-detects framework, optimizes automatically
- **Edge Functions**: Serverless functions deploy to global edge network (low latency)
- **Preview Deployments**: Every PR gets preview URL (test before merging)
- **Rollbacks**: Instant rollback to previous deployment if issues detected
- **Environment Variables**: Secure storage, different values per environment

**Deployment Environments**:
- **Production**: `main` branch → Auto-deploy → agents.nestassociates.com
- **Staging**: `develop` branch → Auto-deploy → staging.agents.nestassociates.com
- **Preview**: Feature branches → Auto-deploy → random-hash.vercel.app

**Why Vercel over Alternatives**:
- **vs. Netlify**: Vercel better for Next.js (created by Vercel team), similar pricing
- **vs. AWS Amplify**: More complex, Vercel simpler for JAMstack
- **vs. Self-hosted**: Higher operational overhead, no auto-scaling

**Alternatives Considered**:
- **Netlify**: Good but Vercel has first-class Next.js support
- **Cloudflare Pages**: Limited to static sites, no serverless functions
- **AWS (ECS/Lambda)**: Much more complex, higher operational cost

**Implementation Notes**:
- `vercel.json` configures build settings, redirects, headers
- Separate Vercel projects for dashboard and agent site template
- Environment variables stored in Vercel dashboard (encrypted)
- Build command: `turbo run build --filter=@nest/dashboard` (or `@nest/agent-site`)

**CI/CD Pipeline**:
1. PR opened → GitHub Actions runs tests
2. Tests pass → Vercel creates preview deployment
3. PR merged to `develop` → Auto-deploy to staging
4. Staging validated → PR to `main` → Auto-deploy to production

**Resources**:
- [Vercel Documentation](https://vercel.com/docs)
- [Vercel Build Configuration](https://vercel.com/docs/build-step)

---

## 17. Performance Optimization

### Decision: Multi-Tier Optimization Strategy

**Rationale**:
- **Static Generation**: Agent sites are fully static (no server runtime)
- **Image Optimization**: Next.js Image component, Astro Image component (WebP, responsive sizes)
- **Code Splitting**: Automatic in Next.js, manual in Astro (only hydrate needed components)
- **CDN**: Vercel Edge Network distributes static assets globally
- **Database Optimization**: Indexes on frequently queried columns, PostGIS spatial indexes

**Optimization Techniques**:

1. **Agent Microsites (Target: <1s load)**:
   - Static HTML/CSS/JS (no SSR overhead)
   - Critical CSS inlined in `<head>`
   - Defer non-critical JS
   - Lazy load images below fold
   - Preconnect to external domains (Mapbox, GA4)
   - Font optimization (subset fonts, preload)

2. **Dashboard (Target: <2s load)**:
   - Server Components (reduced JS bundle)
   - Streaming SSR (fast TTFB)
   - Route prefetching (instant navigation)
   - Debounced search inputs
   - Pagination for long lists

3. **API Endpoints (Target: <200ms p95)**:
   - Database connection pooling
   - Query optimization (avoid N+1, use joins)
   - Caching for public endpoints (5-minute TTL)
   - Efficient RLS policies (don't over-filter)

4. **Build System (Target: <30s per build)**:
   - Parallel processing (20 concurrent builds)
   - Incremental builds (only rebuild changed content)
   - Optimize Astro config (reduce bundle size)

**Database Indexes**:
```sql
-- Properties table
CREATE INDEX idx_properties_agent_id ON properties(agent_id);
CREATE INDEX idx_properties_postcode ON properties(postcode);
CREATE INDEX idx_properties_price ON properties(price);
CREATE INDEX idx_properties_transaction_type ON properties(transaction_type);
CREATE INDEX idx_properties_is_featured ON properties(is_featured) WHERE is_featured = true;

-- Content submissions table
CREATE INDEX idx_content_status_agent_id ON content_submissions(status, agent_id);
CREATE INDEX idx_content_published_at ON content_submissions(published_at) WHERE status = 'published';

-- Build queue table
CREATE INDEX idx_build_queue_processing ON build_queue(priority, created_at) WHERE status = 'pending';

-- Territories spatial index (PostGIS)
CREATE INDEX idx_territories_boundary ON territories USING GIST(boundary);
```

**Image Optimization**:
- Convert images to WebP format on upload (Supabase Storage or Next.js Image)
- Generate responsive sizes (thumbnail, small, medium, large, original)
- Lazy load images below fold
- Use `loading="lazy"` attribute
- Set explicit width/height to prevent layout shift

**Resources**:
- [Next.js Image Optimization](https://nextjs.org/docs/app/building-your-application/optimizing/images)
- [Astro Image Optimization](https://docs.astro.build/en/guides/images/)
- [Web Vitals](https://web.dev/vitals/)

---

## 18. Security Best Practices

### Decision: Defense in Depth

**Rationale**:
- **Multiple Layers**: No single point of failure, layered security controls
- **Least Privilege**: Users/services get minimum permissions needed
- **Audit Logging**: Track all sensitive operations for compliance
- **Input Validation**: Validate on client, server, and database layers

**Security Layers**:

1. **Authentication Layer**:
   - Supabase Auth with JWT tokens (1-hour expiry)
   - Refresh token rotation
   - 2FA for admin accounts (TOTP)
   - Rate limiting on login endpoint

2. **Authorization Layer**:
   - Next.js middleware (route-level checks)
   - API route guards (function-level checks)
   - RLS policies (row-level checks in database)

3. **Input Validation Layer**:
   - Client-side: React Hook Form + Zod (UX, fast feedback)
   - Server-side: API routes validate with Zod (prevent bypass)
   - Database: Constraints, triggers (last line of defense)

4. **Data Protection**:
   - Service role key only in server-side code (never client)
   - Encrypt sensitive data at rest (Supabase default)
   - HTTPS only (enforced by Vercel)
   - Secure cookies (httpOnly, secure, sameSite)

5. **External API Security**:
   - Webhook signature verification (HMAC-SHA256)
   - API key rotation policy
   - Rate limiting (100 req/min per IP)

**OWASP Top 10 Coverage**:
- **A01 Broken Access Control**: RLS policies, middleware checks
- **A02 Cryptographic Failures**: HTTPS, encrypted secrets, bcrypt passwords
- **A03 Injection**: Parameterized queries, Zod validation
- **A04 Insecure Design**: Threat modeling, secure architecture
- **A05 Security Misconfiguration**: Environment variables, no default passwords
- **A06 Vulnerable Components**: Dependabot, npm audit
- **A07 Auth Failures**: 2FA, rate limiting, session expiry
- **A08 Data Integrity Failures**: Webhook signatures, checksums
- **A09 Logging Failures**: Audit logs, Sentry error tracking
- **A10 SSRF**: Validate external URLs, no user-provided URLs in fetch

**Audit Log Schema**:
```sql
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(id),
  entity_type TEXT NOT NULL,
  entity_id UUID NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('create', 'update', 'delete', 'view')),
  old_values JSONB,
  new_values JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
```

**Resources**:
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheets](https://cheatsheetseries.owasp.org/)
- [Supabase Security Best Practices](https://supabase.com/docs/guides/platform/going-into-prod)

---

## Summary of Key Decisions

| Category | Decision | Rationale |
|----------|----------|-----------|
| **Monorepo** | Turborepo | Fast incremental builds, parallel execution, shared config |
| **Dashboard** | Next.js 14 App Router | Server Components, API routes, Vercel integration |
| **Agent Sites** | Astro 4.x | Zero JS by default, fast builds, perfect for static content |
| **Database** | Supabase (PostgreSQL + PostGIS) | All-in-one platform, RLS for security, PostGIS for geospatial |
| **Auth** | Supabase Auth | JWT-based, 2FA support, integrates with Next.js |
| **UI Components** | shadcn/ui (Radix + Tailwind) | Accessible, customizable, no runtime overhead |
| **Forms** | React Hook Form + Zod | Performant, type-safe, DRY validation |
| **Rich Text** | Tiptap | Headless, extensible, accessible |
| **Maps** | Mapbox GL JS + PostGIS | Vector maps, drawing tools, efficient geospatial queries |
| **Email** | Resend | Best DX, React email templates, good deliverability |
| **Testing** | Playwright + Jest | E2E + unit tests, fast, cross-browser |
| **Monitoring** | Vercel Analytics + Sentry | Real-time performance, error tracking, custom metrics |
| **Deployment** | Vercel | Zero-config, edge functions, preview deployments |

---

## Next Steps

With all technical decisions made, proceed to **Phase 1: Design & Contracts**:

1. Generate `data-model.md` - Database schema with all tables, relationships, RLS policies
2. Generate `contracts/` - OpenAPI spec for all API endpoints
3. Generate `quickstart.md` - Developer onboarding guide with setup instructions
4. Update agent context file with technology stack

All unknowns from Technical Context have been resolved. Ready to move forward with implementation planning.
